## 编程语言

```zsh
# 作用
用来作为中介,连接硬件和功能(就像作为函数,连接输入和输出)
调用底层硬件的运动来实现相对应的功能
不同的语言,有不同的编译或解释器,但是本质上都是和硬件沟通,达成想要实现的功能
不同的语言,侧重点不同,有的效率高,有的效率低;适合做的事情不一样,但是基本上每种语言都是什么都能干的

# 分类
机器语言:二进制语言(01),计算机可以直接识别和执行的编程语言。
汇编语言:用一组英文标签来代替二进制指令(翻译过的机器语言)
高级语言:最接近人类的语言(开发效率高,执行效率低:需要经过编译,成二进制语言计算机才能执行)

# 解释型
执行方式:边解释边执行（通过解释器逐行翻译并执行）
运行效率:相对较低（每次运行都需解释）
跨平台性:强（依赖解释器，源码通用）
调试难度:较易（可逐行执行，实时查看状态）
开发效率:高（修改后立即测试，无需编译）

# 编译型
执行方式:先编译后执行（通过编译器一次性转换为机器码）
运行效率:高效（直接执行优化后的机器码）
跨平台性:弱（需为不同平台重新编译）
调试难度:较难（需在编译过程中调试）
开发效率:中等到低（修改代码后需重新编译）
```



## 面向对象

```python
面向对象思想是将现实世界中的事物抽象为 “类”（包含属性和方法的模板），
通过实例化 “对象” 来模拟具体事物，并利用对象间的交互（调用方法、传递数据）实现功能，
核心是封装、继承与多态，以更贴近人类认知的方式组织和编写代码
```



### 类和对象

```python
# 类:比如 "汽车" 类，它是对所有汽车的抽象描述
# 包含共同属性（颜色、品牌、排量）和方法（启动、加速、刹车），不具体指向某一辆车
class Car:
    def __init__(self, color, brand):
        self.color = color  # 属性
        self.brand = brand
        
    def start(self):  # 方法
        print(f"{self.brand}汽车启动了")

# 对象:根据 "汽车" 类创建的具体实例，比如一辆黑色的特斯拉 Model 3，它是真实存在的个体，拥有独立的属性值。
# 创建对象（实例化）
my_car = Car("黑色", "特斯拉")
my_car.start()  # 调用对象的方法，输出"特斯拉汽车启动了"

# self 是一个特殊的参数，用于指代当前实例对象本身。它的核心作用是将类中定义的属性和方法与具体的实例对象绑定，确保每个对象能独立维护自己的数据和行为

# 魔法方法
# 魔法方法是 Python 中以双下划线__开头和结尾的特殊方法，用于实现对象的特定行为，如初始化、运算、字符串表示等
class Book:
    def __init__(self, title, price):
        # 初始化魔法方法：创建对象时自动调用
        self.title = title
        self.price = price

    def __str__(self):
        # 字符串表示魔法方法：print()或str()时调用
        return f"《{self.title}》售价：{self.price}元"

    def __repr__(self):
        # 官方字符串表示：交互式环境或repr()时调用
        return f"Book(title='{self.title}', price={self.price})"

    def __add__(self, other):
        # 加法魔法方法：实现两个对象的加法
        if isinstance(other, Book):
            return self.price + other.price
        return self.price + other

    def __len__(self):
        # 长度魔法方法：len()函数调用时使用
        return len(self.title)


# 使用示例
book1 = Book("Python编程", 59)
book2 = Book("数据结构", 69)

print(book1)  # 调用__str__()：《Python编程》售价：59元
print(repr(book2))  # 调用__repr__()：Book(title='数据结构', price=69)
print(book1 + book2)  # 调用__add__()：128
print(len(book1))  # 调用__len__()：6（"Python编程"的长度）


# 方法重写
class Animal:
    def __init__(self, name):
        self.name = name

    def make_sound(self):
        # 父类的基础方法
        return "未知叫声"

    def move(self):
        # 父类的基础方法
        return "未知移动方式"


class Dog(Animal):
    # 重写父类的make_sound方法
    def make_sound(self):
        return "汪汪汪"

    # 重写父类的move方法
    def move(self):
        return "四条腿奔跑"


class Bird(Animal):
    # 重写父类的make_sound方法
    def make_sound(self):
        return "叽叽喳喳"

    # 重写父类的move方法
    def move(self):
        return "展翅飞翔"


# 使用示例
dog = Dog("旺财")
bird = Bird("小翠")

print(dog.name, "叫声：", dog.make_sound())  # 旺财 叫声：汪汪汪
print(dog.name, "移动：", dog.move())        # 旺财 移动：四条腿奔跑

print(bird.name, "叫声：", bird.make_sound())# 小翠 叫声：叽叽喳喳
print(bird.name, "移动：", bird.move())      # 小翠 移动：展翅飞翔


# 方法重载
# 在同一个类中，允许定义多个同名方法，但这些方法的参数列表（参数数量、参数类型或参数顺序）必须不同
# 同名不同参,调用看参数
class Calculator:
    def add(self, *args):
        """根据传入参数的数量，计算总和"""
        if len(args) == 1:
            return args[0]** 2
        elif len(args) >= 2:
            return sum(args)
        else:
            return 0  # 无参数时返回0

calc = Calculator()
print(calc.add(5))        # 1个参数：25
print(calc.add(3, 4))     # 2个参数：7
print(calc.add(1, 2, 3))  # 3个参数：6
print(calc.add(2, 3, 4, 5)) # 4个参数：14
```



### 封装

```python
# 将对象的属性和方法隐藏在类内部，只通过公开接口操作。
class BankAccount:
    def __init__(self, account_number, name, initial_balance=0):
        # 公开属性：允许直接访问
        self.account_number = account_number  # 账号
        self.name = name                      # 账户名
        
        # 私有属性：用双下划线开头，限制外部直接访问
        self.__balance = initial_balance      # 余额
        self.__password = "123456"            # 密码（默认初始密码）
    
    # 公开方法：查询余额（提供读取私有属性的接口）
    def check_balance(self, password):
        if self.__verify_password(password):
            return f"账户{self.account_number}余额：{self.__balance}元"
        else:
            return "密码错误，无法查询余额"
    
    # 公开方法：存款（提供修改私有属性的接口）
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return f"存款成功，当前余额：{self.__balance}元"
        else:
            return "存款金额必须大于0"
    
    # 公开方法：取款（提供修改私有属性的接口）
    def withdraw(self, amount, password):
        if not self.__verify_password(password):
            return "密码错误，无法取款"
        if amount <= 0:
            return "取款金额必须大于0"
        if amount > self.__balance:
            return "余额不足，取款失败"
        
        self.__balance -= amount
        return f"取款成功，当前余额：{self.__balance}元"
    
    # 公开方法：修改密码（提供修改私有属性的接口）
    def change_password(self, old_pwd, new_pwd):
        if self.__verify_password(old_pwd):
            self.__password = new_pwd
            return "密码修改成功"
        else:
            return "原密码错误，修改失败"
    
    # 私有方法：验证密码（内部使用，不对外公开）
    def __verify_password(self, password):
        return self.__password == password


# 使用示例
if __name__ == "__main__":
    # 创建账户对象
    account = BankAccount("6222021234567890123", "张三", 1000)
    
    # 正常操作（通过公开接口）
    print(account.check_balance("123456"))  # 密码正确，可查询
    print(account.deposit(500))             # 存款成功
    print(account.withdraw(300, "123456"))  # 取款成功
    
    # 尝试直接访问私有属性（会失败）
    print(account.__balance)  # 报错：'BankAccount' object has no attribute '__balance'
    print(account.__password) # 报错：'BankAccount' object has no attribute '__password'
    
    # 密码错误的情况
    print(account.check_balance("wrong"))   # 密码错误，拒绝查询
    print(account.withdraw(200, "wrong"))   # 密码错误，拒绝取款
```



### 继承

```python

# 父类：动物
class Animal:
    def __init__(self, name, age):
        self.name = name  # 名字属性
        self.age = age    # 年龄属性
    
    def eat(self):
        # 所有动物共有的吃方法
        return f"{self.name}正在吃东西"
    
    def sleep(self):
        # 所有动物共有的睡觉方法
        return f"{self.name}正在睡觉"


# 子类：狗（继承自动物）
class Dog(Animal):
    def __init__(self, name, age, breed):
        # 调用父类的初始化方法
        super().__init__(name, age)
        self.breed = breed  # 新增品种属性
    
    # 重写父类方法（实现子类特有行为）
    def eat(self):
        return f"{self.name}（{self.breed}）叼着骨头啃得很香"
    
    # 子类新增方法
    def bark(self):
        return f"{self.name}汪汪叫：旺~旺~"


# 子类：猫（继承自动物）
class Cat(Animal):
    def __init__(self, name, age, color):
        super().__init__(name, age)
        self.color = color  # 新增颜色属性
    
    # 重写父类方法
    def eat(self):
        return f"{self.name}（{self.color}色）优雅地吃着小鱼干"
    
    # 子类新增方法
    def meow(self):
        return f"{self.name}喵喵叫：喵~喵~"


# 使用示例
if __name__ == "__main__":
    # 创建狗对象
    dog = Dog("旺财", 3, "金毛")
    print(dog.sleep())  # 继承父类方法：旺财正在睡觉
    print(dog.eat())    # 调用重写的方法：旺财（金毛）叼着骨头啃得很香
    print(dog.bark())   # 调用子类新增方法：旺财汪汪叫：旺~旺~
    
    # 创建猫对象
    cat = Cat("咪咪", 2, "白")
    print(cat.sleep())  # 继承父类方法：咪咪正在睡觉
    print(cat.eat())    # 调用重写的方法：咪咪（白色）优雅地吃着小鱼干
    print(cat.meow())   # 调用子类新增方法：咪咪喵喵叫：喵~喵~
```



### 多态

```python
# 不同子类对同一方法有不同实现，调用时根据对象类型自动选择。比如 "猫" 和 "狗" 都继承 "动物" 类，但叫声不同。
# 父类：形状
class Shape:
    def area(self):
        """计算面积的方法，父类中定义为抽象方法"""
        raise NotImplementedError("子类必须实现area方法")

# 子类：圆形
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    # 重写父类的area方法（多态体现）
    def area(self):
        return 3.14 * self.radius ** 2

# 子类：矩形
class Rectangle(Shape):
    def __init__(self, length, width):
        self.length = length
        self.width = width
    
    # 重写父类的area方法（多态体现）
    def area(self):
        return self.length * self.width

# 子类：三角形
class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    # 重写父类的area方法（多态体现）
    def area(self):
        return 0.5 * self.base * self.height

# 通用函数：计算任意形状的面积（多态的应用）
def calculate_area(shape):
    # 无需判断shape具体类型，直接调用area方法
    return f"该形状的面积是：{shape.area()}"


# 使用示例
if __name__ == "__main__":
    # 创建不同形状的对象
    circle = Circle(5)       # 半径为5的圆
    rectangle = Rectangle(4, 6)  # 长4、宽6的矩形
    triangle = Triangle(3, 8)    # 底3、高8的三角形
    
    # 调用同一函数，传入不同对象，得到不同结果
    print(calculate_area(circle))    # 该形状的面积是：78.5
    print(calculate_area(rectangle)) # 该形状的面积是：24
    print(calculate_area(triangle))  # 该形状的面积是：12
```



### python

```zsh
# 推荐作为辅助语言,用来做小任务
# 功能领域
1.机器学习，人工智能
2.爬虫
3.数据分析
4.自动化，运维
5.Web后端

# 历史
荷兰程序员,希望开发一个像c语言一样全面的去调用计算机接口,并且可以轻松的编程,且易学易用

# 特点
面向对象,解释型,通用,脚本编程语言
简单易用,学习成本低
库众多,功能强大,小工具,企业级应用
语法简单:语法不严格,不要求写分号,不要求指定变量类型
开源:社区强大
免费:不需要担心版权,商业用途
```



## 异常处理

```python
# 语法错误
语法错误是程序执行前必须改正的错误，如少冒号、缩进不当等，会导致程序无法启动

# 逻辑错误
逻辑错误在程序执行过程中出现，如输入非数字内容进行 int 类型转换引发 ValueError，会导致程序终止。

# 2. 常见异常类型示例
def common_exceptions():
    # NameError：使用未定义的变量
    try:
        print(undefined_variable)
    except NameError as e:
        print(f"捕获到NameError: {e}")

    # IndexError：列表索引超出范围
    try:
        my_list = [1, 2, 3]
        print(my_list[5])
    except IndexError as e:
        print(f"捕获到IndexError: {e}")

    # ZeroDivisionError：除数为零
    try:
        result = 10 / 0
    except ZeroDivisionError as e:
        print(f"捕获到ZeroDivisionError: {e}")

    # KeyError：字典键不存在
    try:
        my_dict = {"name": "Alice"}
        print(my_dict["age"])
    except KeyError as e:
        print(f"捕获到KeyError: {e}")

    # AttributeError：对象没有该属性
    try:
        my_str = "hello"
        my_str.append("world")  # 字符串没有append方法
    except AttributeError as e:
        print(f"捕获到AttributeError: {e}")

    # ValueError：值错误
    try:
        int("not_a_number")
    except ValueError as e:
        print(f"捕获到ValueError: {e}")

    # TypeError：类型错误
    try:
        "2" + 2  # 字符串和数字不能直接相加
    except TypeError as e:
        print(f"捕获到TypeError: {e}")


# 3. try-except基本用法
def basic_try_except():
    try:
        num = int(input("请输入一个数字: "))
        print(f"你输入的数字是: {num}")
    except ValueError:
        print("输入错误！请输入有效的数字。")


# 4. 捕获多个具体异常
def multiple_exceptions():
    try:
        num1 = int(input("请输入第一个数字: "))
        num2 = int(input("请输入第二个数字: "))
        result = num1 / num2
        print(f"结果是: {result}")
    except ValueError:
        print("输入错误！请输入有效的数字。")
    except ZeroDivisionError:
        print("错误：除数不能为零！")


# 5. 万能异常捕获
def catch_all_exceptions():
    try:
        # 可能发生多种异常的代码
        data = [1, 2, 3]
        print(data[10])
        result = 10 / 0
    except Exception as e:  # 捕获所有非语法错误的异常
        print(f"发生了错误: {e}")
        print(f"错误类型: {type(e).__name__}")


# 6. else和finally的使用
def else_and_finally():
    file = None
    try:
        file = open("example.txt", "r")
        content = file.read()
        print("文件内容读取成功")
    except FileNotFoundError:
        print("错误：文件不存在")
    else:
        # 只有try块没有异常时才执行
        print(f"文件长度: {len(content)}")
    finally:
        # 无论是否有异常都会执行
        print("执行finally块")
        if file:
            file.close()
            print("文件已关闭")


# 7. 异常的传递性
def func1():
    return int(input("请输入一个数字"))


def func2():
    func1()
    print("func2")

# 对主函数进行异常处理即可
try:
    func2()
except Exception as e:
    print(e)


# 8. 主动抛出异常(rase关键字爬出异常对象)
def validate_password(password):
    if len(password) < 8:
        # 主动创建并抛出异常
        raise Exception(f"密码长度不足！当前长度: {len(password)}, 至少需要8位")
    print("密码验证通过")

def raise_exception_demo():
    try:
        user_password = input("请输入密码: ")
        validate_password(user_password)
    except Exception as e:
        print(f"密码错误: {e}")
```



## 文件操作

```python
# 文件的定义与作用
文件是存储在长期存储设备（如硬盘）上的一段数据，可永久访问（除非手动删除），能实现数据存储，方便后续执行时直接使用，避免重复制作；而内存存储程序执行中数据，关机后消失。文件处理可实现与计算机文件的交互，如读取、写入和管理文件内容，满足自动化办公等需求，如批量修改文件数据、提取文件名数据写入文件。

# 文件的分类
分为文本文件和二进制文件。文本文件如.txt、.py、.java 等，可用文本编辑器打开；二进制文件如图片、音频（.mp3）、视频（.mp4）等，以二进制形式存储。但无论哪种文件，最终在电脑上均以二进制形式存储，因电脑仅能识别二进制这一底层机器语言
    
'''
文件打开与关闭
'''

用open()函数打开文件，操作后必须用close()关闭以释放资源，支持绝对路径 / 相对路径，需指定访问模式和编码（文本文件）

# 1. 相对路径（文件与Python脚本同目录）
file1 = open("user.txt", mode="r", encoding="utf-8")  # 只读模式打开文本文件
content = file1.read()
print(content)
file1.close()  # 必须关闭

# 2. 绝对路径（Windows需用双反斜杠，mac/Linux用单斜杠）
file2 = open("C:\\Users\\Admin\\data.txt", mode="w", encoding="utf-8")  # 写入模式
file2.write("Hello, 绝对路径!")
file2.close()

# with文件管理器
with 语句自动管理文件打开 / 关闭，避免手动 close 遗漏导致的资源泄漏，文件仅在缩进代码块内可用

'''
文件读操作（3 种常用方法）
'''

# read ()：读取全部内容
# 读取小文件（一次性读全）
with open("user.txt", "r", encoding="utf-8") as f:
    all_content = f.read()  # 返回字符串，包含文件所有内容
    print("全部内容：", all_content)

# readline ():逐行读取
# 读取大文件（避免内存占用过高）
with open("user.txt", "r", encoding="utf-8") as f:
    line1 = f.readline()  # 读第1行
    line2 = f.readline()  # 读第2行
    print("第1行：", line1.strip())  # strip()去除换行符
    print("第2行：", line2.strip())

# readlines ():读取所有行到列表
# 按行处理数据（如拆分用户信息）
with open("user.txt", "r", encoding="utf-8") as f:
    lines = f.readlines()  # 返回列表，每个元素是一行内容
    for line in lines:
        user_info = line.strip().split(",")  # 按逗号拆分（如"张三,123456,13800138000"）
        print("用户名：", user_info[0], "密码：", user_info[1])

'''
文件写操作（2 种常用方法）
'''

# write ():写入单个字符串
# 1. w模式：清空原内容后写入（文件不存在则新建）
with open("log.txt", "w", encoding="utf-8") as f:
    f.write("2025-10-02 操作日志：\n")  # \n表示换行
    f.write("用户登录成功\n")

# 2. a模式：追加到文件末尾（不清空原内容）
with open("log.txt", "a", encoding="utf-8") as f:
    f.write("用户退出系统\n")

# writelines ()：批量写入序列（列表 / 元组）
# 批量写入多行数据
user_list = [
    "李四,654321,13900139000\n",
    "王五,987654,13700137000\n"
]
with open("user.txt", "a", encoding="utf-8") as f:
    f.writelines(user_list)  # 需手动加\n，否则内容会连在一起

'''
二进制文件操作（图片 / 音频 / 视频）
'''

用rb（读二进制）、wb（写二进制）模式，无需指定编码，数据以bytes类型处理。

# 复制图片（读取原图片二进制数据，写入新文件）
with open("original.png", "rb") as f_read:  # 读二进制文件
    img_data = f_read.read()  # 返回bytes类型，存储图片二进制信息

with open("copied.png", "wb") as f_write:  # 写二进制文件
    f_write.write(img_data)  # 将二进制数据写入新文件

print("图片复制完成！")


'''
文件指针操作（重置读取位置）
'''

with open("user.txt", "r", encoding="utf-8") as f:
    # 1. 读取前5个字符
    part1 = f.read(5)
    print("前5个字符：", part1)
    print("当前指针位置：", f.tell())  # 查看指针位置（字节数）

    # 2. 重置指针到文件开头（0表示开头位置）
    f.seek(0)
    print("重置后指针位置：", f.tell())

    # 3. 再次读取全部内容
    all_content = f.read()
    print("再次读全部：", all_content)
    
# 综合实例:用户管理系统 + base64 加密
import base64  # 用于密码的base64编码（加密）和解码（解密）

class UserManager:
    def __init__(self, file_path):
        # 初始化：接收文件路径（存储用户信息的文件）
        self.file_path = file_path

    def add_user(self, username, password):
        """添加用户：密码用base64加密后，通过with追加写入文件"""
        # 步骤1：密码加密（视频重点：字符串→二进制→base64编码）
        # 1.1 字符串转二进制（base64加密要求输入为字节类型）
        password_bytes = password.encode("utf-8")
        # 1.2 base64编码（加密），返回加密后的二进制
        encrypted_pwd = base64.b64encode(password_bytes)
        # 1.3 加密后的二进制转字符串（方便写入文件）
        encrypted_pwd_str = encrypted_pwd.decode("utf-8")

        # 步骤2：用with追加写入文件（自动关闭，避免资源泄漏）
        with open(self.file_path, "a", encoding="utf-8") as f:
            f.write(f"{username}:{encrypted_pwd_str}\n")  # 格式：用户名:加密密码
        print(f"用户「{username}」添加成功！")

    def get_user(self):
        """获取所有用户：用with读取文件，解密密码后返回列表"""
        user_list = []  # 存储所有用户信息（字典格式）

        # 步骤1：用with读取文件（自动关闭）
        with open(self.file_path, "r", encoding="utf-8") as f:
            # 遍历文件每一行（视频：文件对象是可迭代对象，直接for循环）
            for line in f:
                # 去除行首尾的换行符/空格（视频中处理换行的细节）
                line = line.strip()
                if not line:  # 跳过空行
                    continue
                # 按冒号分割：获取用户名和加密后的密码
                username, encrypted_pwd_str = line.split(":")

                # 步骤2：密码解密（视频重点：base64解码→二进制→字符串）
                # 2.1 加密字符串转二进制
                encrypted_pwd_bytes = encrypted_pwd_str.encode("utf-8")
                # 2.2 base64解码（解密）
                decrypted_pwd_bytes = base64.b64decode(encrypted_pwd_bytes)
                # 2.3 二进制转字符串（原始密码）
                decrypted_pwd = decrypted_pwd_bytes.decode("utf-8")

                # 步骤3：添加到列表（字典格式，方便查看）
                user_list.append({
                    "username": username,
                    "password": decrypted_pwd  # 解密后的原始密码
                })

        return user_list
# 1. 创建用户管理对象（指定存储用户信息的文件路径）
user_manager = UserManager("user.txt")

# 2. 添加2个用户（密码会自动加密存储）
user_manager.add_user("admin", "Admin@123")  # 用户名：admin，密码：Admin@123
user_manager.add_user("zhangsan", "Zhang123!")  # 用户名：zhangsan，密码：Zhang123!

# 3. 获取所有用户（解密密码后展示）
print("\n所有用户信息：")
users = user_manager.get_user()
for idx, user in enumerate(users, 1):
    print(f"{idx}. 用户名：{user['username']}，密码：{user['password']}")
```



## 函数式编程

### 闭包

```python
# 闭包是指在一个外函数内部定义的内函数，它引用了外函数的局部变量，并且外函数返回该内函数的引用，从而使内函数能在外部环境中继续访问和使用外函数已结束生命周期的局部变量的特殊函数结构
def temperature_converter(unit):
    # 外层函数接收转换单位
    def converter(temp):
        # 内层函数使用外层函数的unit参数
        if unit == "c2f":  # 摄氏度转华氏度
            return temp * 9/5 + 32
        elif unit == "f2c":  # 华氏度转摄氏度
            return (temp - 32) * 5/9
        else:
            return "未知单位"
    return converter  # 返回内层函数

# 创建两个转换器（闭包实例）
c_to_f = temperature_converter("c2f")
f_to_c = temperature_converter("f2c")

# 使用闭包，无需重复指定转换单位
print(c_to_f(0))   # 输出：32.0（0℃转华氏度）
print(f_to_c(32))  # 输出：0.0（32℉转摄氏度）
```



### 递归函数

```python
# 递归函数是指在函数的定义或实现过程中，直接或间接调用自身，且必须包含终止条件以避免无限循环的函数。
# 阶乘 n! = n × (n-1) × ... × 1
def factorial(n):
    # 结束条件：n=1时返回1
    if n == 1:
        return 1
    # 递归调用：n! = n × (n-1)!
    return n * factorial(n-1)
	print(n)

print(factorial(5))  # 输出：120（5×4×3×2×1）

# 处理任意层级的嵌套列表，无需知道嵌套深度
def print_nested_list(lst):
    for item in lst:
        # 如果元素是列表，递归调用自身
        if isinstance(item, list):
            print_nested_list(item)
        # 否则直接打印元素
        else:
            print(item, end=" ")

# 测试多层嵌套列表
nested_list = [1, [2, 3], [4, [5, 6, [7]]], 8]
print_nested_list(nested_list)  # 输出：1 2 3 4 5 6 7 8
```



### 迭代器和生成器

```python
# 迭代器是 Python 中实现了__iter__和__next__方法、支持逐步取值且仅能向前的对象，可高效节省内存

# 区分迭代与简单重复
# 非迭代：无关联的简单重复（每次结果无依赖）
while True:
    print(1)  # 永远输出1，无“基于前一次结果”的推进

# 迭代：基于前一次结果的重复（N每次自增，依赖上一次值）
n = 0
while n < 5:
    print(n)  # 输出：0 1 2 3 4
    n += 1  # 下一次结果依赖本次n的自增

# 可迭代对象:__iter__方法
# 1. 检查常见对象是否为可迭代对象（通过hasattr判断是否有__iter__方法）
str_obj = "python"
list_obj = [1,2,3]
dict_obj = {"name":"张三", "age":20}

print(hasattr(str_obj, "__iter__"))  # True（字符串是可迭代对象）
print(hasattr(list_obj, "__iter__"))  # True（列表是可迭代对象）
print(hasattr(dict_obj, "__iter__"))  # True（字典是可迭代对象）

# 2. 可迭代对象转迭代器（调用__iter__方法）
list_iter = list_obj.__iter__()  # 或 iter(list_obj)
print(type(list_iter))  # <class 'list_iterator'>（转换为迭代器）

# 生成器是一种特殊迭代器，通过生成器表达式（圆括号推导式）或含yield的函数创建，能惰性生成数据，兼具迭代器优势且实现更简洁

# 1. 列表推导式（一次性加载所有数据到内存）
list_comp = [x*2 for x in range(1,4)]
print(list_comp)  # [2,4,6]（直接生成完整列表）
print(type(list_comp))  # <class 'list'>

# 2. 生成器表达式（圆括号，仅在需要时生成数据）
gen_expr = (x*2 for x in range(1,4))
print(gen_expr)  # <generator object <genexpr> at 0x0000...>（不直接生成数据）
print(type(gen_expr))  # <class 'generator'>

# 3. 遍历生成器（按需取值）
for val in gen_expr:
    print(val)  # 输出：2 4 6（每次循环生成一个值，用完释放内存）

# yield     
def fib_generator(n):
    """生成器函数：生成前n个斐波那契数"""
    a, b = 0, 1  # 初始值
    count = 0
    while count < n:
        yield a  # 1. 返回a的值；2. 暂停函数，保留当前状态
        a, b = b, a + b  # 恢复执行后，执行此句（更新a、b）
        count += 1

# 使用生成器函数
fib_gen = fib_generator(5)  # 调用函数，返回生成器对象（不执行函数体）

# 第一次调用next()：执行到yield a，返回0，暂停
print(next(fib_gen))  # 0
# 第二次调用next()：从暂停处继续，执行a,b更新，count+1，再到yield a返回1，暂停
print(next(fib_gen))  # 1
# 第三次调用next()：重复逻辑，返回1
print(next(fib_gen))  # 1
# 用for循环遍历剩余值（自动处理StopIteration）
for val in fib_gen:
    print(val)  # 输出：2 3
    
# send()
def chat_generator():
    """生成器函数：接收外部输入，实现简单对话"""
    # yield作为“接收值的表达式”，send()发送的值会赋给msg
    msg = yield "你好！请说一句话："
    yield f"你说：{msg}，我收到啦！"

# 1. 初始化生成器（首次必须用next()，不能直接send()）
chat_gen = chat_generator()
print(next(chat_gen))  # 输出：你好！请说一句话：（执行到第一个yield，暂停）

# 2. 用send()发送值并获取下一个结果
print(chat_gen.send("今天天气不错！"))  # 输出：你说：今天天气不错！，我收到啦！

# 3. 关闭生成器（释放资源）
chat_gen.close()
# print(next(chat_gen))  # 生成器已关闭，抛出StopIteration错误
```



### 装饰器

```python
# 装饰器本质是 Python 中的函数（或类），属于闭包的应用，它能在不修改被装饰对象（函数或类）源代码及调用方式的前提下，为其动态添加或扩展功能，遵循开放封闭原则，使代码更简洁、灵活且易于维护;把函数作为参数放到一个新的函数中,增加扩展功能
import time
import random

# 1. 计算函数运行时间的装饰器
def decorate(fnc):
    def calculate_time(*args, **kwargs):
        # 记录开始时间
        start = time.time()
        # 执行被装饰的函数
        result = fnc(*args, **kwargs)
        # 记录结束时间
        end = time.time()
        # 计算并打印运行时间
        print(f"{fnc.__name__}函数运行时间: {end - start:.2f}秒")
        return result
    return calculate_time

# 使用装饰器
@decorate
def download(file_name):
    print(f"开始下载{file_name}...")
    # 模拟下载耗时（随机2-6秒）
    time.sleep(random.randint(2, 6))
    print(f"{file_name}下载完成")

@decorate
def upload(file_name):
    print(f"开始上传{file_name}...")
    # 模拟上传耗时（随机2-6秒）
    time.sleep(random.randint(2, 6))
    print(f"{file_name}上传完成")


# 2. 登录验证装饰器
def login_required(fnc):
    def wrapper(name):
        # 验证用户名是否为"ABC"
        if name == "ABC":
            # 验证通过，执行原函数
            return fnc(name)
        else:
            # 验证失败，提示错误
            print("登录失败：用户名不正确")
    return wrapper

# 使用装饰器
@login_required
def hello(name):
    print(f"Hello, {name}!")


# 测试代码
if __name__ == "__main__":
    # 测试计时装饰器
    download("video.mp4")
    upload("document.pdf")
    
    # 测试登录验证装饰器
    hello("ABC")    # 验证通过
    hello("123")    # 验证失败

```



## 多任务编程

多任务：指计算机在同一时间区间内交替或同时执行多个任务，以提升效率,分为并发（交替执行）和并行（真正同时执行）两种方式

### 进程

```python
'''
进程：是操作系统进行资源分配的基本单位，指正在运行的程序或应用，每个进程拥有独立的内存空间，相互之间默认不共享数据
操作系统资源分配单位，独立内存空间，不共享全局变量，创建开销大，稳定性强，适用于计算密集型任务。
'''

# 例 1：多进程实现任务异步执行（对比单任务串行）
import multiprocessing
import time

# 定义任务函数：吃饭
def eat(name, interval):
    for i in range(3):
        print(f"{name}正在吃饭，第{i+1}次")
        time.sleep(interval)

# 定义任务函数：喝水
def drink(name, interval):
    for i in range(3):
        print(f"{name}正在喝水，第{i+1}次")
        time.sleep(interval)

if __name__ == "__main__":
    # 单任务串行执行（总耗时约 3*1 + 3*0.5 = 4.5 秒）
    print("=== 单任务串行执行 ===")
    start_time = time.time()
    eat("小明", 1)
    drink("小明", 0.5)
    print(f"单任务总耗时：{time.time() - start_time:.2f}秒\n")

    # 多进程异步执行（总耗时约 3*1 = 3 秒，受最长任务耗时决定）
    print("=== 多进程异步执行 ===")
    start_time = time.time()
    # 创建进程对象，指定任务、参数
    p1 = multiprocessing.Process(target=eat, args=("小明", 1), name="吃饭进程")
    p2 = multiprocessing.Process(target=drink, args=("小明", 0.5), name="喝水进程")
    # 启动进程
    p1.start()
    p2.start()
    # 等待进程执行完成
    p1.join()
    p2.join()
    print(f"多进程总耗时：{time.time() - start_time:.2f}秒")

# 例 2：进程不共享全局变量（验证独立内存空间）
import multiprocessing
import time

# 定义全局变量
global_list = []

# 任务1：向全局列表添加数据
def add_data():
    for i in range(3):
        global_list.append(i)
        print(f"添加数据后列表：{global_list}（添加进程PID：{multiprocessing.current_process().pid}）")
        time.sleep(0.5)

# 任务2：读取全局列表数据
def read_data():
    time.sleep(1)  # 等待添加进程执行一段时间
    print(f"\n读取到的列表：{global_list}（读取进程PID：{multiprocessing.current_process().pid}）")

if __name__ == "__main__":
    print(f"主进程PID：{multiprocessing.current_process().pid}，初始全局列表：{global_list}")
    
    # 创建并启动进程
    p_add = multiprocessing.Process(target=add_data)
    p_read = multiprocessing.Process(target=read_data)
    p_add.start()
    p_read.start()
    p_add.join()
    p_read.join()
    
    print(f"\n主进程最终全局列表：{global_list}（验证主进程与子进程内存独立）")

# 例 3：守护进程特性（主进程结束则守护进程终止）
import multiprocessing
import time

# 任务1：非守护进程（主进程会等待其完成）
def non_daemon_task():
    print("非守护进程启动，将执行5秒")
    time.sleep(5)
    print("非守护进程执行完成")

# 任务2：守护进程（主进程结束则终止）
def daemon_task():
    print("守护进程启动，将执行2秒")
    time.sleep(2)
    print("守护进程执行完成（若主进程已结束，此句不会打印）")

if __name__ == "__main__":
    print("主进程启动")
    
    # 创建非守护进程
    p_non_daemon = multiprocessing.Process(target=non_daemon_task)
    # 创建守护进程（需在start前设置daemon=True）
    p_daemon = multiprocessing.Process(target=daemon_task, daemon=True)
    
    # 启动进程
    p_non_daemon.start()
    p_daemon.start()
    
    # 主进程延迟0.5秒后结束
    time.sleep(0.5)
    print("主进程结束")
    
    # 注：主进程会等待非守护进程p_non_daemon完成，但不会等待守护进程p_daemon

# 例 4：进程间通信（Queue 实现生产者 - 消费者模型）
import multiprocessing
import time

# 生产者任务：生产数据并放入队列
def producer(queue):
    for i in range(10):
        egg = f"鸡蛋{i+1}"
        queue.put(egg)  # 向队列存数据
        print(f"生产者生产：{egg}，当前队列大小：{queue.qsize()}")
        time.sleep(0.3)

# 消费者任务：从队列取数据并处理
def consumer(queue):
    while True:
        if not queue.empty():
            egg = queue.get()  # 从队列取数据
            print(f"消费者消费：{egg}，当前队列大小：{queue.qsize()}")
            time.sleep(0.3)
        else:
            # 队列空时退出（需确保生产者先完成）
            print("队列已空，消费者退出")
            break

if __name__ == "__main__":
    # 创建队列（默认无大小限制）
    egg_queue = multiprocessing.Queue()
    
    # 创建并启动进程
    p_producer = multiprocessing.Process(target=producer, args=(egg_queue,))
    p_consumer = multiprocessing.Process(target=consumer, args=(egg_queue,))
    
    p_producer.start()
    p_producer.join()  # 等待生产者生产完所有数据
    
    p_consumer.start()
    p_consumer.join()
    
'''
进程池:
定义：预先创建固定数量的进程，重复利用这些进程执行多个任务，避免频繁创建 / 销毁进程的开销，是管理进程的高效工具。
特点：每个进程有独立内存空间，稳定性高（单个进程崩溃不影响其他），适用于计算密集型任务（如大量数值计算），能充分利用多核 CPU。
核心作用：控制进程数量，减少系统资源抢占，提升程序执行效率。
'''
from concurrent.futures import ProcessPoolExecutor
import time

# 定义任务函数：模拟工人干活
def task(name):
    print(f"工人{name}开始干活")
    time.sleep(5)  # 模拟任务执行耗时（IO/计算操作）
    print(f"工人{name}结束干活")
    return f"工人{name}任务完成"

if __name__ == "__main__":
    # 1. 创建进程池，指定最大进程数为10（默认等于CPU核数）
    pool = ProcessPoolExecutor(max_workers=10)
    
    # 2. 提交50个任务，用列表保存future对象（避免立即获取结果导致同步）
    future_list = []
    for i in range(1, 51):  # 50个工人（任务）
        future = pool.submit(task, name=i)  # 提交任务，传入参数
        future_list.append(future)
    
    # 3. 关闭进程池：等待所有任务执行完毕后再继续
    pool.shutdown()
    
    # 4. 遍历future列表，获取所有任务结果
    for future in future_list:
        result = future.result()  # 阻塞获取结果（此时所有任务已完成，无阻塞）
        print(result)
```



### 线程

```python
'''
CPU 调度基本单位，依附于进程，共享进程内存空间，创建开销小，适用于 IO 密集型任务。
'''

'''
线程创建与任务执行（执行 “吃饭”“喝水” 任务）
''' 
import threading
import time

# 定义线程要执行的任务函数
def eat(name, duration):
    print(f"{name}开始吃饭")
    time.sleep(duration)  # 模拟吃饭耗时
    print(f"{name}吃饭结束")

def drink(name, duration):
    print(f"{name}开始喝水")
    time.sleep(duration)  # 模拟喝水耗时
    print(f"{name}喝水结束")

# 创建线程对象，通过args传递参数（元组形式）
thread1 = threading.Thread(target=eat, args=("小明", 2))
thread2 = threading.Thread(target=drink, args=("小红", 1))

# 启动线程
thread1.start()
thread2.start()

# 等待线程执行完毕（可选，非必须）
thread1.join()
thread2.join()
print("所有任务完成")

'''
线程间共享全局变量（共享列表与变量修改）
'''

# 共享列表添加数据（正常共享场景）
import threading

# 定义全局列表（线程共享）
global_list = []

# 向列表添加数据的任务函数
def add_data(num):
    for i in range(num):
        global_list.append(i)
        print(f"当前列表：{global_list}")

# 创建两个线程，共同操作全局列表
thread_a = threading.Thread(target=add_data, args=(3,))
thread_b = threading.Thread(target=add_data, args=(2,))

thread_a.start()
thread_b.start()
thread_a.join()
thread_b.join()
print("最终列表：", global_list)  # 输出可能为[0,1,0,1,2]（顺序由CPU调度决定）

# 共享变量修改（资源竞争场景）
import threading

# 定义全局变量（线程共享）
global_num = 0

# 修改全局变量的任务函数
def modify_num(count):
    global global_num
    for _ in range(count):
        global_num += 1  # 看似简单的累加，多线程下可能出现资源竞争

# 创建两个线程，各累加1000次
thread1 = threading.Thread(target=modify_num, args=(1000,))
thread2 = threading.Thread(target=modify_num, args=(1000,))

thread1.start()
thread2.start()
thread1.join()
thread2.join()

# 预期结果为2000，但实际可能小于2000（资源竞争导致数据错乱）
print("最终全局变量值：", global_num)

'''
守护线程与非守护线程对比
'''

import threading
import time

# 非守护线程任务（默认）
def non_daemon_task():
    print("非守护线程开始执行")
    time.sleep(3)  # 耗时操作
    print("非守护线程执行完毕")

# 守护线程任务
def daemon_task():
    print("守护线程开始执行")
    time.sleep(5)  # 耗时超过主线程
    print("守护线程执行完毕")  # 主线程结束后，此句不会打印

# 创建非守护线程（默认daemon=False）
non_daemon_thread = threading.Thread(target=non_daemon_task)
# 创建守护线程（需手动设置daemon=True，且必须在start()前设置）
daemon_thread = threading.Thread(target=daemon_task, daemon=True)

# 启动线程
non_daemon_thread.start()
daemon_thread.start()

# 主线程执行简单逻辑后结束
print("主线程开始等待...")
time.sleep(1)  # 主线程等待1秒
print("主线程执行完毕")

# 结果说明：主线程结束后，守护线程被强制终止；非守护线程会继续执行到完毕

'''
使用 join () 解决资源竞争（保证线程执行顺序）
'''
import threading

global_num = 0

def modify_num(count):
    global global_num
    for _ in range(count):
        global_num += 1

# 创建两个线程
thread1 = threading.Thread(target=modify_num, args=(1000,))
thread2 = threading.Thread(target=modify_num, args=(1000,))

# 先启动thread1，用join()等待其执行完毕后再启动thread2
thread1.start()
thread1.join()  # 主线程阻塞，直到thread1执行完
thread2.start()
thread2.join()

# 此时无资源竞争，结果稳定为2000
print("最终全局变量值（join()保证顺序）：", global_num)

'''
使用互斥锁解决资源竞争（保证同一时刻单线程操作）
互斥锁（Lock）：解决线程间共享全局变量的数据安全问题，确保同一时刻仅一个线程操作共享资源，需手动加锁（acquire()）和释放锁（release()），避免死锁。
'''
import threading

global_num = 0
# 创建互斥锁对象
lock = threading.Lock()

def modify_num_with_lock(count):
    global global_num
    for _ in range(count):
        lock.acquire()  # 加锁：同一时刻只有一个线程能进入此代码块
        global_num += 1
        lock.release()  # 解锁：释放锁，允许其他线程进入

# 创建两个线程
thread1 = threading.Thread(target=modify_num_with_lock, args=(1000,))
thread2 = threading.Thread(target=modify_num_with_lock, args=(1000,))

thread1.start()
thread2.start()
thread1.join()
thread2.join()

# 互斥锁保证数据安全，结果稳定为2000
print("最终全局变量值（互斥锁保证安全）：", global_num)

'''
线程池:
定义：预先创建固定数量的线程，重复利用这些线程执行任务，避免频繁创建 / 销毁线程的开销，是管理线程的高效工具。
特点：线程共享所属进程的内存空间，切换开销小于进程，适用于IO 密集型任务（如文件读写、网络通信）。
核心作用：控制线程并发度，减少线程管理开销，避免 IO 等待时 CPU 空闲。
'''
from concurrent.futures import ThreadPoolExecutor
import time

# 定义任务函数：计算数字的平方
def task(n):
    print(f"线程开始执行：计算{n}的平方")
    time.sleep(2)  # 模拟IO耗时（如网络请求、文件读写）
    result = n * n
    print(f"线程执行完毕：{n}的平方是{result}")
    return result

# 定义回调函数：任务完成后自动调用，获取结果
def get_result(future):
    print(f"回调函数获取结果：{future.result()}")

if __name__ == "__main__":
    # 1. 创建线程池，指定最大线程数为5（默认等于CPU核数）
    pool = ThreadPoolExecutor(max_workers=5)
    
    # 2. 提交20个任务，绑定回调函数（任务完成后自动触发get_result）
    for i in range(1, 21):  # 计算1-20的平方
        future = pool.submit(task, n=i)
        future.add_done_callback(get_result)  # 注册回调函数
    
    # 3. 关闭线程池：等待所有任务执行完毕
    pool.shutdown()

'''
协程:
定义：用户态的 “微线程”，通过代码层面的上下文切换，在单线程内实现并发，无需操作系统参与线程调度。
特点：切换开销极小（仅保存代码执行状态），适用于IO 密集型任务（如多接口请求）；计算密集型任务中使用会降低效率（切换消耗抵消收益）。
核心作用：在单线程内最大化 CPU 利用率，解决 IO 等待导致的 CPU 空闲问题。
'''
from gevent import spawn, monkey
import time

# 打猴子补丁：让gevent能检测到系统级IO（如time.sleep、网络请求）
monkey.patch_all()

# 定义3个任务函数（模拟IO密集型操作）
def task1():
    for _ in range(3):
        print("任务1：执行中")
        time.sleep(2)  # 模拟IO等待，会被gevent检测并切换任务

def task2():
    for _ in range(3):
        print("任务2：执行中")
        time.sleep(1)  # 模拟IO等待，会被gevent检测并切换任务

def task3():
    for _ in range(1):
        print("任务3：执行中")
        time.sleep(3)  # 模拟IO等待，会被gevent检测并切换任务

if __name__ == "__main__":
    start_time = time.time()
    
    # 1. 创建协程对象，提交3个任务
    g1 = spawn(task1)
    g2 = spawn(task2)
    g3 = spawn(task3)
    
    # 2. 等待所有协程任务执行完毕
    g1.join()
    g2.join()
    g3.join()
    
    end_time = time.time()
    print(f"总耗时：{end_time - start_time:.2f}秒")  # 结果约3秒（等于最久任务耗时）
```


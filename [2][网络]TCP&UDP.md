TCP(Transmission Control Protocol，传输控制协议)是互联网核心协议之一，作为面向连接的、可靠的、基于字节流的传输层通信协议，TCP为应用层提供了稳定可靠的数据传输服务。

---

### **1. TCP（传输控制协议）**
**特点**：  
- **面向连接**：通信前需通过"三次握手"建立连接，结束时通过"四次挥手"断开连接。  
- **可靠传输**：通过确认应答（ACK）、超时重传、流量控制、拥塞控制等机制确保数据不丢失、不重复、按序到达。  
- **有序性**：数据包按发送顺序重组。  
- **流控制**：通过滑动窗口机制动态调整发送速率，避免接收方过载。  

**典型应用场景**：  
- 需要高可靠性的服务：  
  - **网页浏览**（HTTP/HTTPS）  
  - **文件传输**（FTP、SFTP）  
  - **电子邮件**（SMTP、IMAP）  
  - **远程登录**（SSH、RDP）  

**缺点**：  
- 建立连接和保证可靠性的机制会引入额外开销（延迟、带宽占用）。  

---

### **2. UDP（用户数据报协议）**
**特点**：  
- **无连接**：直接发送数据包，无需预先建立连接。  
- **不可靠传输**：不保证数据到达、不保证顺序、不重传丢失的包。  
- **轻量高效**：无复杂控制机制，头部仅8字节（TCP至少20字节）。  
- **支持广播/多播**：可同时向多个目标发送数据。  

**典型应用场景**：  
- 对实时性要求高于可靠性的服务：  
  - **视频/语音通话**（Zoom、WebRTC）  
  - **在线游戏**（实时位置同步）  
  - **DNS查询**（快速响应比可靠性更重要）  
  - **IoT传感器数据**（如温度传感器的周期性上报）  

**缺点**：  
- 可能丢包或乱序，需应用层自行处理（如通过前向纠错或时间戳）。  

---

### **核心区别对比**
| 特性                | TCP                          | UDP                          |
|---------------------|------------------------------|------------------------------|
| 连接方式            | 面向连接（三次握手）         | 无连接                       |
| 可靠性              | 可靠（确认、重传）           | 不可靠                       |
| 数据顺序            | 保证按序到达                 | 不保证顺序                   |
| 流量控制            | 有（滑动窗口）               | 无                           |
| 传输效率            | 较低（头部开销大）           | 较高（头部精简）             |
| 适用场景            | 文件传输、网页浏览           | 实时视频、语音、游戏         |

---

### **Linux中的协议选择**
在编程中，开发者需显式指定协议类型：  
```bash
# 查看服务使用的协议（如SSH默认用TCP）
grep ssh /etc/services

# 手动测试UDP端口（TCP默认工具如telnet不适用）
nc -u -zv example.com 53  # 测试DNS（UDP）
```

### 三次握手

TCP 通过三次握手建立可靠的双向连接，确保通信双方都能正常收发数据。

---

#### **1. 三次握手流程**
假设客户端（Client）想要与服务器（Server）建立连接：

| 步骤 | 方向       | 报文类型 | 关键字段                | 作用说明                                                                 |
|------|------------|----------|-------------------------|--------------------------------------------------------------------------|
| 1    | Client → Server | `SYN`     | `SYN=1, seq=x`          | 客户端随机生成初始序列号（`x`），发起连接请求。                          |
| 2    | Server → Client | `SYN+ACK` | `SYN=1, ACK=1, seq=y, ack=x+1` | 服务器确认客户端的`SYN`（`ack=x+1`），并发送自己的初始序列号（`y`）。    |
| 3    | Client → Server | `ACK`     | `ACK=1, seq=x+1, ack=y+1`      | 客户端确认服务器的`SYN`，连接正式建立。                                  |

**可视化流程**：
```
Client                            Server
  |                                |
  |-------- SYN (seq=x) ----------->|
  |                                |
  |<-- SYN+ACK (seq=y, ack=x+1) ---|
  |                                |
  |------- ACK (ack=y+1) --------->|
  |                                |
  |         [连接建立]              |
```

---

#### **2. 关键机制解析**
- **序列号（Sequence Number）**：  
  - 初始序列号（ISN）是随机生成的，防止历史报文被误用（安全考虑）。  
  - 后续数据包的序列号按字节流递增（如`seq=x+1`表示已发送`x`字节）。  

- **确认号（Acknowledgment Number）**：  
  - `ack=x+1` 表示"已收到序列号`x`的数据，期待下次收到`x+1`"。  

- **为什么需要三次？**  
  - **两次不够**：如果只有两次握手，服务器无法确认客户端是否收到了自己的`SYN+ACK`（可能因丢包导致服务器单方面维持无用连接）。  
  - **四次冗余**：三次已能确保双向通信能力，四次会增加不必要的开销。

---

#### **3. 抓包分析（Wireshark示例）**
用 `tcpdump` 抓取握手过程（以SSH连接为例）：
```bash
sudo tcpdump -i any tcp port 22 -nn -vv
```
**输出示例**：
```
# 1. Client发送SYN
IP 192.168.1.100.54321 > 192.168.1.1.22: Flags [S], seq 123456789, win 64240

# 2. Server回复SYN+ACK
IP 192.168.1.1.22 > 192.168.1.100.54321: Flags [S.], seq 987654321, ack 123456790, win 65535

# 3. Client发送ACK
IP 192.168.1.100.54321 > 192.168.1.1.22: Flags [.], ack 987654322, win 64240
```

---

#### **4. 握手失败场景**
- **SYN Flood攻击**：攻击者伪造大量`SYN`包但不完成握手，耗尽服务器资源。  
  **防御**：启用 `SYN Cookies`（Linux内核参数 `net.ipv4.tcp_syncookies=1`）。  

- **端口未监听**：服务器直接回复`RST`（复位）包拒绝连接。  

- **网络延迟**：客户端未收到`SYN+ACK`时会超时重传`SYN`（默认重试5次，间隔1s/2s/4s/8s/16s）。

---

#### **5. 相关Linux命令**
- 查看TCP连接状态：  
  ```bash
  ss -t -a  # 或 `netstat -tulnp`
  ```
- 调整握手参数（内核优化）：  
  ```bash
  sysctl -w net.ipv4.tcp_syn_retries=3  # 减少SYN重试次数
  sysctl -w net.ipv4.tcp_synack_retries=3
  ```

---

#### **6. 扩展问题**
- **为什么初始序列号是随机的？**  
  防止伪造IP和端口的主机预测序列号（历史安全问题，如IP欺骗攻击）。  

- **握手后如何传输数据？**  
  后续数据包的`seq`和`ack`会基于握手阶段的初始值递增（如客户端发送的第一个数据包`seq=x+1`）。  

### **TCP 四次挥手（Four-Way Handshake）详解**
TCP 通过四次挥手（Four-Way Handshake）**安全关闭连接**，确保双方数据完整传输，避免资源泄漏。以下是详细流程和底层机制：

---

## **1. 四次挥手流程**
假设 **客户端（Client）** 主动关闭连接，**服务器（Server）** 被动关闭：

| 步骤 | 方向       | 报文类型 | 关键字段                | 作用说明                                                                 |
|------|------------|----------|-------------------------|--------------------------------------------------------------------------|
| 1    | Client → Server | `FIN`     | `FIN=1, seq=u`          | 客户端发送 `FIN`，表示不再发送数据，但仍可接收数据。                    |
| 2    | Server → Client | `ACK`     | `ACK=1, ack=u+1`        | 服务器确认 `FIN`，但可能仍有数据要发送（进入 `CLOSE_WAIT` 状态）。      |
| 3    | Server → Client | `FIN`     | `FIN=1, seq=v, ack=u+1` | 服务器发送 `FIN`，表示数据已发送完毕，准备关闭连接（进入 `LAST_ACK` 状态）。 |
| 4    | Client → Server | `ACK`     | `ACK=1, ack=v+1`        | 客户端确认 `FIN`，进入 `TIME_WAIT` 状态，等待 2MSL 后彻底关闭。         |

**可视化流程**：
```
Client                            Server
  |                                |
  |-------- FIN (seq=u) ----------->| (Client → FIN_WAIT_1)
  |                                |
  |<------- ACK (ack=u+1) ---------| (Server → CLOSE_WAIT)
  |                                |
  |<------- FIN (seq=v) -----------| (Server → LAST_ACK)
  |                                |
  |-------- ACK (ack=v+1) -------->| (Client → TIME_WAIT)
  |                                |
  |         [连接关闭]              |
```

---

## **2. 关键机制解析**
### **(1) 为什么需要四次挥手？**
- **TCP 是全双工的**，即双方可以独立发送和接收数据：
  - 客户端发送 `FIN` 表示 **不再发送数据**，但仍可接收数据。
  - 服务器可能仍有数据要发送，所以先回复 `ACK`，等数据发完再发送 `FIN`。
  - 如果服务器没有数据要发送，可以合并 `ACK` 和 `FIN`（变成三次挥手，但标准是四次）。

### **(2) `TIME_WAIT` 状态的作用**
- 客户端在发送最后一个 `ACK` 后进入 `TIME_WAIT`，等待 **2MSL（Maximum Segment Lifetime，报文最大生存时间，默认 60s）**：
  - **确保最后一个 `ACK` 到达服务器**（如果丢失，服务器会重传 `FIN`）。
  - **防止旧连接的延迟报文干扰新连接**（相同四元组的新连接不会被旧数据混淆）。

### **(3) 异常情况**
- **服务器未收到 `ACK`**：
  - 服务器会重传 `FIN`，客户端在 `TIME_WAIT` 期间可以重新发送 `ACK`。
- **客户端崩溃**：
  - 服务器会一直处于 `LAST_ACK` 状态，直到超时后关闭连接（`tcp_fin_timeout` 控制）。

---

## **3. 抓包分析（Wireshark / tcpdump）**
用 `tcpdump` 抓取挥手过程（以关闭 SSH 连接为例）：
```bash
sudo tcpdump -i any tcp port 22 -nn -vv
```
**输出示例**：
```
# 1. Client发送FIN
IP 192.168.1.100.54321 > 192.168.1.1.22: Flags [F], seq 123456790, win 64240

# 2. Server回复ACK
IP 192.168.1.1.22 > 192.168.1.100.54321: Flags [.], ack 123456791, win 65535

# 3. Server发送FIN
IP 192.168.1.1.22 > 192.168.1.100.54321: Flags [F.], seq 987654322, ack 123456791, win 65535

# 4. Client回复ACK
IP 192.168.1.100.54321 > 192.168.1.1.22: Flags [.], ack 987654323, win 64240
```

---

## **4. 相关 Linux 命令**
### **(1) 查看 TCP 连接状态**
```bash
ss -t -a  # 或 `netstat -tulnp`
```
**示例输出**：
```
State      Recv-Q Send-Q Local Address:Port  Peer Address:Port  
FIN_WAIT1  0      0      192.168.1.100:54321 192.168.1.1:22     
CLOSE_WAIT 0      0      192.168.1.1:22      192.168.1.100:54321
TIME_WAIT  0      0      192.168.1.100:54321 192.168.1.1:22
```

### **(2) 调整 TCP 挥手参数**
```bash
# 减少 TIME_WAIT 时间（默认 60s）
sysctl -w net.ipv4.tcp_fin_timeout=30

# 允许重用 TIME_WAIT 状态的端口（适用于高并发服务器）
sysctl -w net.ipv4.tcp_tw_reuse=1
sysctl -w net.ipv4.tcp_tw_recycle=1  #（谨慎使用，可能影响 NAT 环境）
```

---

## **5. 常见问题**
### **(1) 为什么 `TIME_WAIT` 要等 2MSL？**
- **确保最后一个 `ACK` 到达服务器**（如果丢失，服务器会重传 `FIN`）。
- **防止旧连接的延迟报文干扰新连接**（相同四元组的新连接不会被旧数据混淆）。

### **(2) 服务器出现大量 `CLOSE_WAIT` 状态？**
- **原因**：应用程序没有正确关闭 Socket（如未调用 `close()`）。
- **解决方案**：检查代码逻辑，确保资源释放。

### **(3) 可以合并 `ACK` 和 `FIN` 吗？**
- **可以**，但标准实现是四次挥手。某些优化场景（如 HTTP/1.1 Keep-Alive）可能会合并。
